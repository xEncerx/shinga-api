"""initial

Revision ID: 79bdd5942c16
Revises: 
Create Date: 2025-07-09 19:10:46.015622

"""
from typing import Sequence, Union

import sqlmodel.sql.sqltypes
import sqlalchemy as sa

from alembic import op

from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '79bdd5942c16'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('titles',
    sa.Column('id', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('cover', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('name_en', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('name_ru', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('alt_names', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('type_', sa.Enum('MANGA', 'NOVEL', 'LIGHT_NOVEL', 'ONESHOT', 'DOUJIN', 'MANHWA', 'MANHUA', 'COMICS', 'WEBTOON', 'OTHER', name='titletype'), nullable=False),
    sa.Column('chapters', sa.Integer(), nullable=False),
    sa.Column('volumes', sa.Integer(), nullable=False),
    sa.Column('views', sa.Integer(), nullable=False),
    sa.Column('in_app_rating', sa.Float(), nullable=True),
    sa.Column('in_app_scored_by', sa.Integer(), nullable=True),
    sa.Column('status', sa.Enum('ONGOING', 'FINISHED', 'DISCONTINUED', 'LICENSED', 'FROZEN', 'ANONS', 'UNKNOWN', name='titlestatus'), nullable=False),
    sa.Column('date', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('rating', sa.Float(), nullable=False),
    sa.Column('scored_by', sa.Integer(), nullable=False),
    sa.Column('popularity', sa.Integer(), nullable=False),
    sa.Column('favorites', sa.Integer(), nullable=False),
    sa.Column('description', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('authors', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('genres', postgresql.ARRAY(sa.Enum('ACTION', 'ADVENTURE', 'AVANT_GARDE', 'AWARD_WINNING', 'GENDER_INTRIGUE', 'HEROIC_FANTASY', 'BOYS_LOVE', 'COMEDY', 'DRAMA', 'COMBAT', 'HUMOR', 'MURIM', 'SCHOOL_LIFE', 'FANTASTIC', 'THRILLER', 'TRAGEDY', 'PSYCHOLOGY', 'POST_APOCALYPTIC', 'ELEMENTS_OF_HUMOR', 'KODOMO', 'KIDS', 'CYBERPUNK', 'HISTORY', 'FANTASY', 'GIRLS_LOVE', 'GOURMET', 'HORROR', 'MYSTERY', 'ROMANCE', 'SCI_FI', 'SLICE_OF_LIFE', 'SPORTS', 'SUPERNATURAL', 'SUSPENSE', 'SEINEN', 'SHOUNEN', 'DOUJINSHI', 'SHOUJO', 'JOSEI', 'YAOI', 'ECCHI', 'EROTICA', 'HENTAI', 'ADULT_CAST', 'ANTHROPOMORPHIC', 'CGDCT', 'CHILDCARE', 'COMBAT_SPORTS', 'CROSSDRESSING', 'DELINQUENTS', 'DETECTIVE', 'EDUCATIONAL', 'GAG_HUMOR', 'GORE', 'HAREM', 'HIGH_STAKES_GAME', 'HISTORICAL', 'IDOLS_FEMALE', 'IDOLS_MALE', 'ISEKAI', 'IYASHIKEI', 'LOVE_POLYGON', 'LOVE_STATUS_QUO', 'MAGICAL_SEX_SHIFT', 'MAHOU_SHOUJO', 'MARTIAL_ARTS', 'MECHA', 'MEDICAL', 'MEMOIR', 'MILITARY', 'MUSIC', 'MYTHOLOGY', 'ORGANIZED_CRIME', 'OTAKU_CULTURE', 'PARODY', 'PERFORMING_ARTS', 'PETS', 'PSYCHOLOGICAL', 'RACING', 'REINCARNATION', 'REVERSE_HAREM', 'SAMURAI', 'SCHOOL', 'SHOWBIZ', 'SPACE', 'STRATEGY_GAME', 'SUPER_POWER', 'SURVIVAL', 'TEAM_SPORTS', 'TIME_TRAVEL', 'URBAN_FANTASY', 'VAMPIRE', 'VIDEO_GAME', 'VILLAINESS', 'VISUAL_ARTS', 'WORKPLACE', name='titlegenre')), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('source_provider', sa.Enum('MAL', 'REMANGA', 'SHIKIMORI', 'CUSTOM', name='sourceprovider'), nullable=False),
    sa.Column('source_id', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('extra_data', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('search_vector', postgresql.TSVECTOR(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_titles_id'), 'titles', ['id'], unique=False)
    op.create_index(op.f('ix_titles_search_vector'), 'titles', ['search_vector'], unique=False)
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sqlmodel.sql.sqltypes.AutoString(length=50), nullable=False),
    sa.Column('email', sqlmodel.sql.sqltypes.AutoString(length=255), nullable=False),
    sa.Column('hashed_password', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('google_id', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('yandex_id', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('is_staff', sa.Boolean(), nullable=False),
    sa.Column('is_superuser', sa.Boolean(), nullable=False),
    sa.Column('avatar', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('avg_rating', sa.Float(), nullable=False),
    sa.Column('count_likes', sa.Integer(), nullable=False),
    sa.Column('count_votes', sa.Integer(), nullable=False),
    sa.Column('count_comments', sa.Integer(), nullable=False),
    sa.Column('count_bookmarks', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('description', sqlmodel.sql.sqltypes.AutoString(length=1000), nullable=True),
    sa.Column('extra_data', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('registration_date', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_google_id'), 'users', ['google_id'], unique=False)
    op.create_index(op.f('ix_users_id'), 'users', ['id'], unique=False)
    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)
    op.create_index(op.f('ix_users_yandex_id'), 'users', ['yandex_id'], unique=False)
    op.create_table('user_titles',
    sa.Column('username', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('title_id', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('user_rating', sa.Integer(), nullable=False),
    sa.Column('current_url', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('bookmark', sa.Enum('NOT_READING', 'READING', 'COMPLETED', 'DROPPED', 'PLANNED', name='bookmarktype'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('extra_data', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.ForeignKeyConstraint(['title_id'], ['titles.id'], ),
    sa.ForeignKeyConstraint(['username'], ['users.username'], ),
    sa.PrimaryKeyConstraint('username', 'title_id')
    )
    op.create_index(op.f('ix_user_titles_title_id'), 'user_titles', ['title_id'], unique=False)
    op.create_index(op.f('ix_user_titles_username'), 'user_titles', ['username'], unique=False)

    # ### TRIGGERS ###
    # Enable pg_trgm extension
    op.execute("CREATE EXTENSION IF NOT EXISTS pg_trgm")
    # Search vector function and trigger
    op.execute("""
    CREATE OR REPLACE FUNCTION update_title_search_vector()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.search_vector := 
            setweight(to_tsvector('russian', COALESCE(NEW.name_ru, '')), 'A') ||
            setweight(to_tsvector('english', COALESCE(NEW.name_en, '')), 'B');
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    """)
    op.execute("""
    CREATE TRIGGER title_search_vector_update
        BEFORE INSERT OR UPDATE ON titles
        FOR EACH ROW
        EXECUTE FUNCTION update_title_search_vector();
    """)
    # Create search indexes
    op.execute("CREATE INDEX idx_title_search_vector ON titles USING GIN(search_vector)")
    op.execute("CREATE INDEX idx_title_name_ru_trigram ON titles USING GIN(name_ru gin_trgm_ops)")
    op.execute("CREATE INDEX idx_title_name_en_trigram ON titles USING GIN(name_en gin_trgm_ops)")

    # Ratings update function and trigger
    op.execute("""
    CREATE OR REPLACE FUNCTION update_ratings_trigger()
    RETURNS TRIGGER AS $$
    DECLARE
        old_rating INTEGER := 0;
        new_rating INTEGER := 0;
        user_current_votes INTEGER := 0;
        user_current_avg DECIMAL := 0;
        title_current_count INTEGER := 0;
        title_current_sum DECIMAL := 0;
    BEGIN
        -- Get old and new ratings
        IF TG_OP = 'DELETE' THEN
            old_rating := OLD.user_rating;
            new_rating := 0;
        ELSIF TG_OP = 'INSERT' THEN
            old_rating := 0;
            new_rating := NEW.user_rating;
        ELSE -- UPDATE
            old_rating := OLD.user_rating;
            new_rating := NEW.user_rating;
        END IF;

        -- Skip if ratings didn't change or both are 0
        IF old_rating = new_rating THEN
            IF TG_OP = 'DELETE' THEN
                RETURN OLD;
            ELSE
                RETURN NEW;
            END IF;
        END IF;

        -- Determine username and title_id based on operation
        DECLARE
            target_username VARCHAR;
            target_title_id VARCHAR;
        BEGIN
            IF TG_OP = 'DELETE' THEN
                target_username := OLD.username;
                target_title_id := OLD.title_id;
            ELSE
                target_username := NEW.username;
                target_title_id := NEW.title_id;
            END IF;

            -- Get current user stats
            SELECT count_votes, avg_rating INTO user_current_votes, user_current_avg
            FROM users WHERE username = target_username;

            -- Update user statistics
            IF old_rating = 0 AND new_rating > 0 THEN
                -- Add new rating
                UPDATE users SET 
                    count_votes = count_votes + 1,
                    avg_rating = CASE 
                        WHEN count_votes = 0 THEN new_rating::DECIMAL
                        ELSE (avg_rating * count_votes + new_rating) / (count_votes + 1)
                    END
                WHERE username = target_username;
                
            ELSIF old_rating > 0 AND new_rating = 0 THEN
                -- Remove rating
                UPDATE users SET 
                    count_votes = GREATEST(count_votes - 1, 0),
                    avg_rating = CASE 
                        WHEN count_votes <= 1 THEN 0
                        ELSE (avg_rating * count_votes - old_rating) / (count_votes - 1)
                    END
                WHERE username = target_username;
                
            ELSIF old_rating > 0 AND new_rating > 0 THEN
                -- Update existing rating
                UPDATE users SET 
                    avg_rating = CASE 
                        WHEN count_votes = 0 THEN new_rating::DECIMAL
                        ELSE (avg_rating * count_votes - old_rating + new_rating) / count_votes
                    END
                WHERE username = target_username;
            END IF;

            -- Get current title stats
            SELECT in_app_scored_by, 
                COALESCE(in_app_rating * in_app_scored_by, 0) as current_sum
            INTO title_current_count, title_current_sum
            FROM titles WHERE id = target_title_id;

            -- Update title statistics
            IF old_rating = 0 AND new_rating > 0 THEN
                -- Add new rating to title
                UPDATE titles SET 
                    in_app_scored_by = in_app_scored_by + 1,
                    in_app_rating = CASE 
                        WHEN in_app_scored_by = 0 THEN new_rating::DECIMAL
                        ELSE (title_current_sum + new_rating) / (in_app_scored_by + 1)
                    END
                WHERE id = target_title_id;
                
            ELSIF old_rating > 0 AND new_rating = 0 THEN
                -- Remove title rating
                UPDATE titles SET 
                    in_app_scored_by = GREATEST(in_app_scored_by - 1, 0),
                    in_app_rating = CASE 
                        WHEN in_app_scored_by <= 1 THEN 0
                        ELSE (title_current_sum - old_rating) / (in_app_scored_by - 1)
                    END
                WHERE id = target_title_id;
                
            ELSIF old_rating > 0 AND new_rating > 0 THEN
                -- Update existing title rating
                UPDATE titles SET 
                    in_app_rating = CASE 
                        WHEN in_app_scored_by = 0 THEN new_rating::DECIMAL
                        ELSE (title_current_sum - old_rating + new_rating) / in_app_scored_by
                    END
                WHERE id = target_title_id;
            END IF;
        END;

        -- Return appropriate record
        IF TG_OP = 'DELETE' THEN
            RETURN OLD;
        ELSE
            RETURN NEW;
        END IF;
    END;
    $$ LANGUAGE plpgsql;
    """)

    op.execute("""
    CREATE TRIGGER rating_update_trigger
        AFTER INSERT OR UPDATE OF user_rating OR DELETE
        ON user_titles
        FOR EACH ROW
        EXECUTE FUNCTION update_ratings_trigger();
    """)

    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_user_titles_username'), table_name='user_titles')
    op.drop_index(op.f('ix_user_titles_title_id'), table_name='user_titles')
    op.drop_table('user_titles')
    op.drop_index(op.f('ix_users_yandex_id'), table_name='users')
    op.drop_index(op.f('ix_users_username'), table_name='users')
    op.drop_index(op.f('ix_users_id'), table_name='users')
    op.drop_index(op.f('ix_users_google_id'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    op.drop_index(op.f('ix_titles_search_vector'), table_name='titles')
    op.drop_index(op.f('ix_titles_id'), table_name='titles')
    op.drop_table('titles')

    # Drop triggers first
    op.execute("DROP TRIGGER IF EXISTS title_search_vector_update ON titles")
    op.execute("DROP TRIGGER IF EXISTS rating_update_trigger ON user_titles")
    
    # Then drop functions
    op.execute("DROP FUNCTION IF EXISTS update_title_search_vector()")
    op.execute("DROP FUNCTION IF EXISTS update_ratings_trigger()")
    
    # Finally drop indexes and extension
    op.execute("DROP INDEX IF EXISTS idx_title_search_vector")
    op.execute("DROP INDEX IF EXISTS idx_title_name_ru_trigram")
    op.execute("DROP INDEX IF EXISTS idx_title_name_en_trigram")
    op.execute("DROP EXTENSION IF EXISTS pg_trgm")
    # ### end Alembic commands ###
